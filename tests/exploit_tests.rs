//! Tests for exploit module
//!
//! This module contains tests for:
//! - Vulnerability context extraction
//! - Localhost payload generation
//! - Response analysis logic
//! - Path fuzz functionality

use smugglex::exploit::{extract_vulnerability_context, get_fuzz_paths, PathFuzzResult, VulnerabilityContext};
use smugglex::model::CheckResult;

#[test]
fn test_extract_vulnerability_context_clte() {
    let results = vec![
        CheckResult {
            check_type: "cl-te".to_string(),
            vulnerable: true,
            payload_index: Some(0),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 504 Gateway Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(5000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("POST / HTTP/1.1\r\nHost: example.com\r\n...".to_string()),
            confidence: None,
        },
        CheckResult {
            check_type: "te-cl".to_string(),
            vulnerable: false,
            payload_index: None,
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: None,
            normal_duration_ms: 100,
            attack_duration_ms: None,
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: None,
            confidence: None,
        },
    ];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload_index, 0);
    assert!(ctx.payload.contains("POST /"));
}

#[test]
fn test_extract_vulnerability_context_tecl() {
    let results = vec![CheckResult {
        check_type: "te-cl".to_string(),
        vulnerable: true,
        payload_index: Some(5),
        normal_status: "HTTP/1.1 200 OK".to_string(),
        attack_status: Some("HTTP/1.1 408 Request Timeout".to_string()),
        normal_duration_ms: 100,
        attack_duration_ms: Some(3000),
        timestamp: "2024-01-01T00:00:00Z".to_string(),
        payload: Some("POST / HTTP/1.1\r\nHost: test.com\r\n...".to_string()),
        confidence: None,
    }];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "te-cl");
    assert_eq!(ctx.payload_index, 5);
}

#[test]
fn test_extract_vulnerability_context_none() {
    let results = vec![CheckResult {
        check_type: "cl-te".to_string(),
        vulnerable: false,
        payload_index: None,
        normal_status: "HTTP/1.1 200 OK".to_string(),
        attack_status: None,
        normal_duration_ms: 100,
        attack_duration_ms: None,
        timestamp: "2024-01-01T00:00:00Z".to_string(),
        payload: None,
        confidence: None,
    }];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_none());
}

#[test]
fn test_extract_vulnerability_context_multiple_vulnerabilities() {
    let results = vec![
        CheckResult {
            check_type: "cl-te".to_string(),
            vulnerable: true,
            payload_index: Some(0),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 504 Gateway Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(5000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("CL.TE payload".to_string()),
            confidence: None,
        },
        CheckResult {
            check_type: "te-cl".to_string(),
            vulnerable: true,
            payload_index: Some(3),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 408 Request Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(3000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("TE.CL payload".to_string()),
            confidence: None,
        },
    ];

    // Should return the first vulnerable result
    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload, "CL.TE payload");
}

#[test]
fn test_vulnerability_context_creation() {
    let ctx = VulnerabilityContext {
        vuln_type: "cl-te".to_string(),
        payload: "test payload".to_string(),
        payload_index: 42,
    };

    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload, "test payload");
    assert_eq!(ctx.payload_index, 42);
}

#[test]
fn test_ports_parsing() {
    let ports_str = "22,80,443,8080,3306";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    assert_eq!(ports.len(), 5);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 80);
    assert_eq!(ports[2], 443);
    assert_eq!(ports[3], 8080);
    assert_eq!(ports[4], 3306);
}

#[test]
fn test_ports_parsing_with_spaces() {
    let ports_str = "22, 80 , 443";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    assert_eq!(ports.len(), 3);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 80);
    assert_eq!(ports[2], 443);
}

#[test]
fn test_ports_parsing_invalid() {
    let ports_str = "22,invalid,443";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    // Should skip invalid entries
    assert_eq!(ports.len(), 2);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 443);
}

// Path fuzz tests

#[test]
fn test_get_fuzz_paths_default() {
    let paths = get_fuzz_paths(None).unwrap();
    assert!(!paths.is_empty());
    // Check that paths start with /
    for path in &paths {
        assert!(path.starts_with('/'), "Path should start with /: {}", path);
    }
    // Check some expected default paths
    assert!(paths.contains(&"/admin".to_string()));
    assert!(paths.contains(&"/test".to_string()));
    assert!(paths.contains(&"/login".to_string()));
}

#[test]
fn test_get_fuzz_paths_default_has_common_paths() {
    let paths = get_fuzz_paths(None).unwrap();
    
    // Check for various categories of common paths
    let admin_paths: Vec<_> = paths.iter().filter(|p| p.contains("admin")).collect();
    assert!(!admin_paths.is_empty(), "Should have admin-related paths");
    
    let api_paths: Vec<_> = paths.iter().filter(|p| p.contains("api")).collect();
    assert!(!api_paths.is_empty(), "Should have API-related paths");
}

#[test]
fn test_get_fuzz_paths_from_wordlist() {
    use std::io::Write;
    
    // Create a temporary wordlist file
    let temp_dir = std::env::temp_dir();
    let wordlist_path = temp_dir.join("test_wordlist.txt");
    
    let mut file = std::fs::File::create(&wordlist_path).unwrap();
    writeln!(file, "custom-path").unwrap();
    writeln!(file, "/already-prefixed").unwrap();
    writeln!(file, "# comment line").unwrap();
    writeln!(file, "").unwrap();
    writeln!(file, "  whitespace-path  ").unwrap();
    drop(file);
    
    let paths = get_fuzz_paths(Some(wordlist_path.to_str().unwrap())).unwrap();
    
    assert_eq!(paths.len(), 3);
    assert!(paths.contains(&"/custom-path".to_string()));
    assert!(paths.contains(&"/already-prefixed".to_string()));
    assert!(paths.contains(&"/whitespace-path".to_string()));
    
    // Cleanup
    std::fs::remove_file(&wordlist_path).ok();
}

#[test]
fn test_get_fuzz_paths_invalid_file() {
    let result = get_fuzz_paths(Some("/nonexistent/path/wordlist.txt"));
    assert!(result.is_err());
}

#[test]
fn test_get_fuzz_paths_empty_wordlist() {
    use std::io::Write;
    
    let temp_dir = std::env::temp_dir();
    let wordlist_path = temp_dir.join("empty_wordlist.txt");
    
    let mut file = std::fs::File::create(&wordlist_path).unwrap();
    writeln!(file, "# only comments").unwrap();
    writeln!(file, "").unwrap();
    drop(file);
    
    let result = get_fuzz_paths(Some(wordlist_path.to_str().unwrap()));
    assert!(result.is_err());
    
    // Cleanup
    std::fs::remove_file(&wordlist_path).ok();
}

#[test]
fn test_path_fuzz_result_creation() {
    let result = PathFuzzResult {
        path: "/admin".to_string(),
        found: true,
        reason: "Status changed to 200 OK".to_string(),
        response_status: Some("HTTP 200".to_string()),
        response_body_preview: Some("Admin panel".to_string()),
    };
    
    assert_eq!(result.path, "/admin");
    assert!(result.found);
    assert!(result.reason.contains("200"));
    assert!(result.response_status.is_some());
    assert!(result.response_body_preview.is_some());
}

#[test]
fn test_path_fuzz_result_not_found() {
    let result = PathFuzzResult {
        path: "/nonexistent".to_string(),
        found: false,
        reason: "No indicators of hidden path".to_string(),
        response_status: None,
        response_body_preview: None,
    };
    
    assert_eq!(result.path, "/nonexistent");
    assert!(!result.found);
    assert!(result.response_status.is_none());
    assert!(result.response_body_preview.is_none());
}
