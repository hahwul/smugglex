//! Tests for exploit module
//!
//! This module contains tests for:
//! - Vulnerability context extraction
//! - Localhost payload generation
//! - Response analysis logic

use smugglex::exploit::{extract_vulnerability_context, VulnerabilityContext};
use smugglex::model::CheckResult;

#[test]
fn test_extract_vulnerability_context_clte() {
    let results = vec![
        CheckResult {
            check_type: "cl-te".to_string(),
            vulnerable: true,
            payload_index: Some(0),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 504 Gateway Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(5000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("POST / HTTP/1.1\r\nHost: example.com\r\n...".to_string()),
        },
        CheckResult {
            check_type: "te-cl".to_string(),
            vulnerable: false,
            payload_index: None,
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: None,
            normal_duration_ms: 100,
            attack_duration_ms: None,
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: None,
        },
    ];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload_index, 0);
    assert!(ctx.payload.contains("POST /"));
}

#[test]
fn test_extract_vulnerability_context_tecl() {
    let results = vec![CheckResult {
        check_type: "te-cl".to_string(),
        vulnerable: true,
        payload_index: Some(5),
        normal_status: "HTTP/1.1 200 OK".to_string(),
        attack_status: Some("HTTP/1.1 408 Request Timeout".to_string()),
        normal_duration_ms: 100,
        attack_duration_ms: Some(3000),
        timestamp: "2024-01-01T00:00:00Z".to_string(),
        payload: Some("POST / HTTP/1.1\r\nHost: test.com\r\n...".to_string()),
    }];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "te-cl");
    assert_eq!(ctx.payload_index, 5);
}

#[test]
fn test_extract_vulnerability_context_none() {
    let results = vec![CheckResult {
        check_type: "cl-te".to_string(),
        vulnerable: false,
        payload_index: None,
        normal_status: "HTTP/1.1 200 OK".to_string(),
        attack_status: None,
        normal_duration_ms: 100,
        attack_duration_ms: None,
        timestamp: "2024-01-01T00:00:00Z".to_string(),
        payload: None,
    }];

    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_none());
}

#[test]
fn test_extract_vulnerability_context_multiple_vulnerabilities() {
    let results = vec![
        CheckResult {
            check_type: "cl-te".to_string(),
            vulnerable: true,
            payload_index: Some(0),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 504 Gateway Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(5000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("CL.TE payload".to_string()),
        },
        CheckResult {
            check_type: "te-cl".to_string(),
            vulnerable: true,
            payload_index: Some(3),
            normal_status: "HTTP/1.1 200 OK".to_string(),
            attack_status: Some("HTTP/1.1 408 Request Timeout".to_string()),
            normal_duration_ms: 100,
            attack_duration_ms: Some(3000),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
            payload: Some("TE.CL payload".to_string()),
        },
    ];

    // Should return the first vulnerable result
    let ctx = extract_vulnerability_context(&results);
    assert!(ctx.is_some());
    let ctx = ctx.unwrap();
    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload, "CL.TE payload");
}

#[test]
fn test_vulnerability_context_creation() {
    let ctx = VulnerabilityContext {
        vuln_type: "cl-te".to_string(),
        payload: "test payload".to_string(),
        payload_index: 42,
    };

    assert_eq!(ctx.vuln_type, "cl-te");
    assert_eq!(ctx.payload, "test payload");
    assert_eq!(ctx.payload_index, 42);
}

#[test]
fn test_ports_parsing() {
    let ports_str = "22,80,443,8080,3306";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    assert_eq!(ports.len(), 5);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 80);
    assert_eq!(ports[2], 443);
    assert_eq!(ports[3], 8080);
    assert_eq!(ports[4], 3306);
}

#[test]
fn test_ports_parsing_with_spaces() {
    let ports_str = "22, 80 , 443";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    assert_eq!(ports.len(), 3);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 80);
    assert_eq!(ports[2], 443);
}

#[test]
fn test_ports_parsing_invalid() {
    let ports_str = "22,invalid,443";
    let ports: Vec<u16> = ports_str
        .split(',')
        .filter_map(|s| s.trim().parse::<u16>().ok())
        .collect();

    // Should skip invalid entries
    assert_eq!(ports.len(), 2);
    assert_eq!(ports[0], 22);
    assert_eq!(ports[1], 443);
}
